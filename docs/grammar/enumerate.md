
# 枚举

## 枚举作为类型

```lumos
enum 枚举类型名 by 值的类型 as type { // as type 可以省略
    枚举元素1 = 值1, // = 值1 可以省略，此时会按照默认值规则自动生成
    枚举元素2 = 值2, // 务必添加尾随逗号
    // ...
}
// 此时 typeof(枚举元素1) is 枚举类型名
```

- `值的类型` 可以是任何基本类型或用户自定义类型，此类型就是枚举实际存储时使用的类型。
- 若需要根据类型自动生成默认值，其必须实现 `\default` 和 `\next` 运算符。

也可以不写值的类型，此时默认为 `i32`。

```lumos
enum 枚举类型名 {
    枚举元素1 = 值1,
    枚举元素2 = 值2,
    // ...
}
```

如果省略值，则第一个枚举元素的值为类型的默认值，之后每个元素的默认值为上一个元素 `\next` 运算的结果。

```lumos
enum 枚举类型名 by i32 {
    枚举元素1, // 默认为 0
    枚举元素2, // 默认为 1
    枚举元素3, // 默认为 2
    // ...
}
```

由于 `string` 类型没有实现 `\next` 运算符，因此不能省略值。

### 将枚举元素转换成其值

可以通过强制转换为其内部类型将枚举元素转换成其值，也可以用适用于 wrapper 的方法。

```lumos
val a = 枚举元素1 as 值的类型;
val b = 枚举元素1 as inner;
```

### 枚举表格

有时候我们需要将一个枚举类型与多个不同类型的值关联，可以使用枚举表格。

```lumos
enum 枚举类型名 by 类型 as table {
    [enum,      类型1, 类型2],
    [枚举元素1, 值1_1, 值1_2],
    [枚举元素2, 值2_1, 值2_2],
    // ...
}
```

此时可以通过 `as 类型` 将枚举元素转换成对应类型的值。

使用示例：

```lumos
enum ReturnCode by i32 as table {
    [enum,     i32, string                 ],
    [OK,       200, "OK"                   ],
    [NotFound, 404, "Not Found"            ],
    [Error,    500, "Internal Server Error"],
}

println(ReturnCode::NotFound as i32);    // 输出 404
println(ReturnCode::NotFound as string); // 输出 "Not Found"
```

## 枚举作为容器

也可以将枚举用作一个容器，其中的元素可以直接参与运算。

```lumos
enum 枚举名 by 值的类型 as container {
    枚举元素1 = 值1,
    枚举元素2 = 值2,
    // ...
}
// 此时 typeof(枚举元素1) is 值的类型
```

注意此时枚举本身并**不是一个类型**，以下代码会导致报错：

```lumos
枚举名 my_var = 枚举元素1; // error: `枚举名` 不是一个类型
```

你也可以认为这是一个只能存放特定类型值的命名空间。

## 限制枚举只在编译期有效

将值的类型设为 `void` 可以阻止枚举元素的值在运行时被访问，此时枚举元素只能用于编译期的判断，在任何地方存储这个值会导致编译错误。

```lumos
enum 枚举名 by void {
    枚举元素1,
    枚举元素2,
    // ...
}
```

## 枚举内函数

枚举作为类型时内部可以定义函数。<br />
但作为容器时只能定义静态函数。

```lumos
enum 枚举名 by 值的类型 as type {
    枚举元素1,
    枚举元素2; // 以分号结尾

    fun 函数名(参数列表) -> 返回类型 {
        // 函数体
    }
    // ...
}
```

```lumos
enum 枚举名 by 值的类型 as container {
    static fun 函数名(参数列表) -> 返回类型 {
        // 函数体
    }
    // ...
}
```
